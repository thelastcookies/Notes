# Hash 散列/哈希

## 什么是 Hash？

Hash，一般翻译做散列，或音译为哈希，是把任意长度的输入通过哈希函数变换成固定长度的输出，该输出就是哈希值。

哈希函数将任何一种数据转换为一个数字指纹（也名数字摘要），这个指纹和源数据的每一个字节都有十分紧密的关系。源数据的微小改动，会造成散列值的巨大差异。

这种转换是一种压缩映射，哈希值的空间通常远小于输入的空间。在压缩过程中丢失了大量信息，因此哈希函数很难找到逆向规律。

不同的输入可能会散列成相同的输出，这种情况称为“哈希碰撞（collision）”。

## 哈希碰撞以及常见处理方法

在计算 Hash 地址的过程中会出现对于不同的关键字出现相同的哈希地址的情况，即 `key1 ≠ key2`，但是 `H(key1) = H(key2)`，这种情况就是 Hash 碰撞。

具有相同关键字的 key1 和 key2 称之为同义词。

通过优化哈希函数可以减少这种冲突的情况，但是在通用条件下，
考虑到于哈希表长度有限而关键值（数据）是无限的，这种冲突是不可避免的，所以就需要处理冲突。

### 常见的碰撞解决方法：

### 1.开放寻址法

这种方法也称再散列法，其基本思想是：出现碰撞后按照一定算法查找一个空位置存放。

当关键字key的哈希地址 `p = H(key)` 出现冲突时，以 p 为基础，产生另一个哈希地址 p1，如果 p1 仍然冲突，再以 p1 为基础，产生另一个哈希地址 p2，…，
直到找出一个不冲突的哈希地址pi ，将相应元素存入其中。

具体算法有：

- 线性探测再散列

  冲突发生时，顺序查看表中下一单元，直到找出一个空单元或查遍全表。

- 二次探测再散列

  冲突发生时，依次向前后查找，增量为1、2、3的二次方。

- 伪随机探测再散列

  冲突发生时，随机产生一个增量位移。

### 2.再哈希法（Rehash）

当发生冲突时，同时构造多个不同的哈希函数计算地址，直到无冲突时。这种方法不易产生聚集，但增加了计算时间。

### 3.链地址法（拉链法）

基本思想是将所有哈希地址相同的元素构成一个称为同义词链的单链表，并将单链表的头指针存在哈希表的第 i 个单元中，
因而查找、插入和删除主要在同义词链中进行。链地址法适用于经常进行插入和删除的情况。

## 在数据结构中的应用 - 哈希表

使用 Hash 算法的数据结构叫做哈希表，也叫散列表。

每当提供 key 值，则通过计算 H(key) 计算 key 值映射数据的存储位置，提高查询的效率。

哈希表在很多编程语言中都有实现， 如 JavaScript 中的 Map，Java 中的 HashMap，Python 中的字典等。

## 在密码学中的应用 - 加密哈希函数

加密哈希函数是一类有特殊属性的哈希函数。

一个好的「加密哈希函数」必须满足抗碰撞（collision-resistant）和不可逆（irreversible）这两个条件。

抗碰撞是指通过统计学方法（彩虹表）很难或几乎不可能猜出哈希值对应的原始数据。

不可逆则是说攻击者很难或几乎不可能从算法层面通过哈希值逆向演算出原始数据。

具体而言，一个理想的加密哈希函数，应当具有如下属性：

- 快速：计算速度要足够快。
- 确定性：对同样的输入，应该总是产生同样的输出。
- 难以分析：对输入的任何微小改动，都应该使输出完全发生变化。
- 不可逆：从其哈希值逆向演算出输入值应该是不可行的。这意味着没有比暴力破解更好的破解方法。
- 无碰撞：找到具有相同哈希值的两条不同消息应该非常困难（或几乎不可能）。

现代加密哈希函数（如 SHA2 和 SHA3）都具有上述几个属性，并被广泛应用在多个领域，各种现代编程语言和平台的标准库中基本都包含这些常用的哈希函数。

量子安全性：现代密码学哈希函数（如 SHA2, SHA3, BLAKE2）都被认为是量子安全的，无惧量子计算机的发展。

### 加密哈希函数的应用

#### 1. 数据完整性校验

加密哈希函数被广泛用于文件完整性校验。如果你从网上下载的文件计算出的 SHA256 校验和（checksum）跟官方公布的一致，那就说明文件没有损坏。

> 在古早的低速网络中，即使网络各协议层有多种数据纠错手段，下载完成的文件仍然是有可能损坏的，这也是哈希函数数据完整性校验存在的历史背景。

#### 2. 保存密码

加密哈希函数还被用于密码的安全存储，现代系统使用专门设计的安全哈希算法计算用户密码的哈希摘要。
保存到数据库中，这样能确保密码的安全性。
除了用户自己，没有人清楚该密码的原始数据，即使数据库管理员也只能看到一个哈希摘要。

#### 3. 生成唯一ID

加密哈希函数也被用于为文档或消息生成（绝大多数情况下）唯一的 ID。

加密哈希函数计算出的哈希值理论上确实有碰撞的概率，但是这个概率实在太小了，因此绝大多数系统（如 Git）都假设哈希函数是无碰撞的（collision free）。

使用哈希值作为唯一 ID 的典型例子，Git 版本控制系统（如 3c3be25bc1757ca99aba55d4157596a8ea217698），比特币地址（如 1BvBMSEYstWetqTFn5Au4m4GFg7xJaNVN2）。

#### 4. 伪随机数生成
   
哈希值可以被当作一个随机数看待。

### 安全的加密哈希算法

#### 1. SHA-2, SHA-256, SHA-512

SHA-2，即 Secure Hash Algorithm 2，是一组强密码哈希函数，其成本包括：SHA-256（256位哈希）、SHA-384（384位哈希）、SHA-512（512位哈希）等。基于密码概念「Merkle–Damgård 构造」，目前被认为高度安全。 SHA-2 是 SHA-1 的继任者，于 2001 年在美国作为官方加密标准发布。

SHA-2 在软件开发和密码学中被广泛使用，可用于现代商业应用。 其中 SHA-256 被广泛用于 HTTPS 协议、文件完整性校验、比特币区块链等各种场景。

```
SHA-256('hello') = 2cf24dba5fb0a30e26e83b2ac5b9e29e1b161e5c1fa7425e73043362938b9824
SHA-384('hello') = 59e1748777448c69de6b800d7a33bbfb9ff1b463e44354c3553bcdb9c666fa90125a3c79f90397bdf5f6a13de828684f
SHA-512('hello') = 9b71d224bd62f3785d96d46ad3ea3d73319bfbc2890caadae2dff72519673ca72323c3d99ba5c11d7c7acc6e14b8c5da0c4663475c2e5c3adef46f73bcdec043
```

#### 2. SHA-3, SHA3-256, SHA3-512, Keccak-256

在输出的哈希长度相同时，SHA-3（及其变体 SHA3-224、SHA3-256、SHA3-384、SHA3-512）被认为拥有比 SHA-2（SHA-224、SHA-256、SHA-384、SHA-512）更高的加密强度。 例如，对于相同的哈希长度（256 位），SHA3-256 提供比 SHA-256 更高的加密强度。

SHA-3 系列函数是 Keccak 哈希家族的代表，它基于密码学概念海绵函数。而 Keccak 是SHA3 NIST 比赛的冠军。

与 SHA-2 不同，SHA-3 系列加密哈希函数不易受到长度拓展攻击 Length extension attack.

SHA-3 被认为是高度安全的，并于 2015 年作为美国官方推荐的加密标准发布。

以太坊（Ethereum）区块链中使用的哈希函数 Keccak-256 是 SHA3-256 的变体，在代码中更改了一些常量。

哈希函数 SHAKE128(msg, length) 和 SHAKE256(msg, length) 是 SHA3-256 和 SHA3-512 算法的变体，它们输出消息的长度可以变化。

```
SHA3-256('hello') = 3338be694f50c5f338814986cdf0686453a888b84f424d792af4b9202398f392
Keccak-256('hello') = 1c8aff950685c2ed4bc3174f3472287b56d9517b9c948127319a09a7a36deac8
SHA3-512('hello') = 75d527c368f2efe848ecf6b073a36767800805e9eef2b1857d5f984f036eb6df891d75f72d9b154518c1cd58835286d1da9a38deba3de98b5a53e5ed78a84976

SHAKE-128('hello', 256) = 4a361de3a0e980a55388df742e9b314bd69d918260d9247768d0221df5262380
SHAKE-256('hello', 160) = 1234075ae4a1e77316cf2d8000974581a343b9eb
```


#### 3. BLAKE2 / BLAKE2s / BLAKE2b
BLAKE / BLAKE2 / BLAKE2s / BLAKE2b 是一系列快速、高度安全的密码学哈希函数，提供 160 位、224 位、256 位、384 位和 512 位摘要大小的计算，在现代密码学中被广泛应用。

BLAKE 进入了SHA3 NIST 比赛的决赛。

- BLAKE2 函数是 BLAKE 的改进版本。
- BLAKE2s（通常为 256 位）是 BLAKE2 实现，针对 32 位微处理器进行了性能优化。
- BLAKE2b（通常为 512 位）是 BLAKE2 实现，针对 64 位微处理器进行了性能优化。

BLAKE2 哈希函数具有与 SHA-3 类似的安全强度，但开发人员目前仍然更倾向于使用 SHA2 和 SHA3。

```
BLAKE2s('hello') = 19213bacc58dee6dbde3ceb9a47cbb330b3d86f8cca8997eb00be456f140ca25
BLAKE2b('hello') = e4cfa39a3d37be31c59609e807970799caa68a19bfaa15135f165085e01d41a65ba1e1b146aeb6bd0092b49eac214c103ccfa3a365954bbbe52f74a2b3620c94
```

#### 4. RIPEMD-160

RIPEMD-160, RIPE Message Digest 是一种安全哈希函数，发布于 1996 年，目前主要被应用在 PGP 和比特币中。

RIPEMD 的 160 位变体在实践中被广泛使用，而 RIPEMD-128、RIPEMD-256 和 RIPEMD-320 等其他变体并不流行，并且它们的安全优势具有争议。

建议优先使用 SHA-2 和 SHA-3 而不是 RIPEMD，因为它们输出的哈希值更长，抗碰撞能力更强。

```
RIPEMD-160('hello') = 108f07b8382412612c048d07d13f814118445acd
```

### PoW 工作量证明哈希函数

区块链中的 Proof-of-Work 工作量证明挖矿算法使用了一类特殊的哈希函数，这些函数是计算密集型和内存密集型的。
这些哈希函数被设计成需要消耗大量计算资源和大量内存，并且很难在硬件设备（例如集成电路或矿机）中实现，也就难以设计专用硬件来加速计算。
这种哈希函数被称为**抗 ASIC（ASIC-resistant）**。

大部分工作量证明（Proof-of-Work）算法，都是要求计算出一个比特定值（称为挖掘难度）更大的哈希值。 因为哈希值是不可预测的，为了找出符合条件的哈希值，
矿工需要计算数十亿个不同的哈希值，再从中找出最大的那个。 
比如，一个工作量证明问题可能会被定义为：已有常数 x，要求找到一个数 p， 使 hash(x + p) 的前十个比特都为 0。

有许多哈希函数是专为工作量证明挖掘算法设计的，例如 ETHash、Equihash、CryptoNight 和 Cookoo Cycle. 这些哈希函数的计算速度很慢，
通常使用 GPU 硬件或强大的 CPU 硬件和大量快速 RAM 内存来执行这类算法。 

目前大型虚拟货币挖矿公司手中的主要武器是 ASIC 矿机，因此，现代加密货币通常会要求使用「抗 ASIC 哈希算法」或「权益证明（proof-of-stake）共识协议」进行「工作量证明挖矿」，以限制这部分高级玩家，达成更好的去中心化。

> 因为工作量证明算法需要消耗大量能源，不够环保，以太坊等区块链已经声明未来将会升级到权益证明（Proof-of-Stake）这类更环保的算法。

#### ETHash

这里简要说明下以太坊区块链中使用的 ETHash 工作量证明挖掘哈希函数背后的思想。

ETHash 是以太坊区块链中的工作量证明哈希函数。它是内存密集型哈希函数（需要大量 RAM 才能快速计算），因此它被认为是抗 ASIC 的。

ETHash 的工作流程：

- 基于直到当前区块的整个链，为每个区块计算一个「种子」
- 从种子中计算出一个 16 MB 的伪随机缓存
- 从缓存中提取 1 GB 数据集以用于挖掘
- 挖掘涉及将数据集的随机切片一起进行哈希

#### Equihash

简要解释一下 Zcash、Bitcoin Gold 和其他一些区块链中使用的 Equihash 工作量证明挖掘哈希函数背后的思想。

Equihash 是 Zcash 和 Bitcoin Gold 区块链中的工作量证明哈希函数。它是内存密集型哈希函数（需要大量 RAM 才能进行快速计算），因此它被认为是抗 ASIC 的。

Equihash 的工作流程：

- 基于直到当前区块的整个链，使用 BLAKE2b 计算出 50 MB 哈希数据集
- 在生成的哈希数据集上解决「广义生日问题」（从 2097152 中挑选 512 个不同的字符串，使得它们的二进制 XOR 为零）。已知最佳的解决方案（瓦格纳算法）在指数时间内运行，因此它需要大量的内存密集型和计算密集型计算
- 对前面得到的结果，进行双 SHA256 计算得到最终结果，即 SHA256(SHA256(solution))

### 不安全的加密哈希算法

一些老一代的加密哈希算法，如 MD5, SHA-0 和 SHA-1 被认为是不安全的，并且都存在已被发现的加密漏洞（碰撞）。

不要使用 MD5、SHA-0 和 SHA-1！这些哈希函数都已被证明不够安全。

使用这些不安全的哈希算法，可能会导致数字签名被伪造、密码泄漏等严重问题！

另外也请避免使用以下被认为不安全或安全性有争议的哈希算法： MD2, MD4, MD5, SHA-0, SHA-1, Panama, HAVAL（有争议的安全性，在 HAVAL-128 上发现了碰撞），Tiger（有争议，已发现其弱点），SipHash（它属于非加密哈希函数）。
